.
└── setOwner(address newOwner) external
    ├── when msg.sender not owner
    │   └── revert with NOT_OWNER
    └── when msg.sender is owner
        ├── it should set owner to newOwner
        └── it should emit SetOwner(newOwner)
.
└── enableIrm(address irm) external
    ├── when msg.sender not owner
    │   └── revert with NOT_OWNER
    └── when msg.sender is owner
        ├── it should set isIrmEnabled[irm] to true
        └── it should emit EnableIrm(irm)
.
└── enableLltv(uint256 lltv) external
    ├── when msg.sender not owner
    │   └── revert with NOT_OWNER
    └── when msg.sender is owner
        ├── when lltv >= WAD
        │   └── revert with LLTV_TOO_HIGH
        └── when lltv < WAD
            ├── it should set isLltvEnabled[lltv] to true
            └── it should emit EnableLltv(lltv)
.
└── setFee(Market memory market, uint256 newFee) external
    ├── when msg.sender not owner
    │   └── revert with NOT_OWNER
    └── when msg.sender is owner
        ├── when market is not created
        │   └── revert with MARKET_NOT_CREATED
        └── when market is created
            ├── when newFee > MAX_FEE
            │   └── revert with MAX_FEE_EXCEEDED
            └── when newFee <= MAX_FEE
                ├── it should accrue the interest
                ├── it should set fee[market.id] to newFee
                └── it should emit SetFee(market.id, newFee)
.
└── setFeeRecipient(address recipient) external
    ├── when msg.sender not owner
    │   └── revert with NOT_OWNER
    └── when msg.sender is owner
        ├── it should set feeRecipient to recipient
        └── it should emit SetFeeRecipient(recipient)
.
└── createMarket(Market memory market) external
    ├── when irm is not enabled
    │   └── revert with IRM_NOT_ENABLED
    └── when irm is enabled
        ├── when market.lltv is not enabled
        │   └── revert with LLTV_NOT_ENABLED
        └── when market.lltv is enabled
            ├── when market is already created
            │   └── revert with MARKET_ALREADY_CREATED
            └── when market is not already created
                ├── it should set lastUpdate[market.id] to block.timestamp
                ├── it should set idToMarket[id] to market
                └── it should emit CreateMarket(market.id, market)
.
└── supply(Market memory market, uint256 assets, uint256 shares, address onBehalf, bytes calldata data) external
    ├── when market is not created
    │   └── revert with MARKET_NOT_CREATED
    └── when market is created
        ├── when both assets and shares are null or both assets and shares are not null
        │   └─  revert with INCONSISTENT_INPUT
        └── when one of assets or shares is null and one of assets or shares is not null
            ├── when onBehalf is the zero address
            │   └── revert with ZERO_ADDRESS
            └── when onBehalf is not the zero address
                ├── it should accrue the interest
                ├── when assets is not zero
                │   └── it should set shares to assets.toSharesUp(totalSupply[market.id], totalSupplyShares[market.id])
                ├── when assets is zero
                │   └── it should set assets to shares.toAssetsDown(totalSupply[id], totalSupplyShares[id])
                ├── it should add shares to supplyShares[market.id][onBehalf] 
                ├── it should add shares to totalSupplyShares[market.id]
                ├── it should add assets to totalSupply[market.id]
                ├── it should emit Supply(market.id, msg.sender, onBehalf, assets, shares)
                ├── if data.length > 0
                │   └── it should call sender's onMorphoSupply callback
                ├── it should transfer assets of the borrowable asset from the sender to Morpho
                └── it should return the assets and the shares supplied
.
└── withdraw(Market memory market, uint256 assets, uint256 shares, address onBehalf, address receiver) external
    ├── when market is not created
    │   └── revert with MARKET_NOT_CREATED
    └── when market is created
        ├── when both assets and shares are null or both assets and shares are not null
        │   └─  revert with INCONSISTENT_INPUT
        └── when one of assets or shares is null and one of assets or shares is not null
            ├── when receiver is the zero address
            │   └── revert with ZERO_ADDRESS
            └── when receiver is not the zero address
                ├── when not sender and not approved
                │   └── revert with UNAUTHORIZED
                └── when sender or approved
                    ├── it should accrue the interest
                    ├── when assets is not zero
                    │   └── it should set shares to assets.toSharesUp(totalSupply[market.id], totalSupplyShares[market.id])
                    ├── when assets is zero
                    │   └── it should set assets to shares.toAssetsDown(totalSupply[id], totalSupplyShares[id])
                    ├── it should remove shares from supplyShares[market.id][onBehalf] 
                    ├── it should remove shares from totalSupplyShares[market.id]
                    ├── it should remove assets from totalSupply[market.id]
                    ├── it should emit Withdraw(market.id, msg.sender, onBehalf, receiver, assets, shares)
                    ├── it should transfer assets of the borrowable asset to the receiver
                    ├── when totalBorrow[market.id] > totalSupply[market.id]
                    │   └── revert with INSUFFICIENT_LIQUIDITY
                    └── when totalBorrow[market.id] <= totalSupply[market.id]
                        └── it should return the assets and the shares withdrawn
.
└── borrow(Market memory market, uint256 assets, uint256 shares, address onBehalf, address receiver) external
    ├── when market is not created
    │   └── revert with MARKET_NOT_CREATED
    └── when market is created
        ├── when both assets and shares are null or both assets and shares are not null
        │   └─  revert with INCONSISTENT_INPUT
        └── when one of assets or shares is null and one of assets or shares is not null
            ├── when receiver is the zero address
            │   └── revert with ZERO_ADDRESS
            └── when receiver is not the zero address
                ├── when not sender and not approved
                │   └── revert with UNAUTHORIZED
                └── when sender or approved
                    ├── it should accrue the interest
                    ├── when assets is not zero
                    │   └── it should set shares to assets.toSharesUp(totalSupply[market.id], totalSupplyShares[market.id])
                    ├── when assets is zero
                    │   └── it should set assets to shares.toAssetsDown(totalSupply[id], totalSupplyShares[id])
                    ├── it should add shares to borrowShares[market.id][onBehalf] 
                    ├── it should add shares to totalBorrowShares[market.id]
                    ├── it should add assets to totalBorrow[market.id]
                    ├── it should emit Borrow(market.id, msg.sender, onBehalf, receiver, assets, shares)
                    ├── it should transfer assets of the borrowable asset to the receiver
                    ├── when position is not healthy
                    │   └── revert with INSUFFICIENT_COLLATERAL
                    └── when position is healthy
                        ├── when totalBorrow[market.id] > totalSupply[market.id]
                        │   └── revert with INSUFFICIENT_LIQUIDITY
                        └── when totalBorrow[market.id] <= totalSupply[market.id]  
                            └── it should return the assets and the shares borrowed
                        
.
└── repay(Market memory market, uint256 assets, uint256 shares, address onBehalf, bytes calldata data) external
    ├── when market is not created
    │   └── revert with MARKET_NOT_CREATED
    └── when market is created
        ├── when both assets and shares are null or both assets and shares are not null
        │   └─  revert with INCONSISTENT_INPUT
        └── when one of assets or shares is null and one of assets or shares is not null
            ├── when onBehalf is the zero address
            │   └── revert with ZERO_ADDRESS
            └── when onBehalf is not the zero address
                ├── it should accrue the interest
                ├── when assets is not zero
                │   └── it should set shares to assets.toSharesUp(totalSupply[market.id], totalSupplyShares[market.id])
                ├── when assets is zero
                │   └── it should set assets to shares.toAssetsDown(totalSupply[id], totalSupplyShares[id])
                ├── it should remove shares from borrowShares[market.id][onBehalf]
                ├── it should remove shares from totalBorrowShares[market.id]
                ├── it should remove assets from totalBorrow[market.id]
                ├── it should emit Repay(market.id, msg.sender, onBehalf, assets, shares)
                ├── if data.length > 0
                │   └── it should call sender's onMorphoRepay callback
                ├── it should transfer assets of the borrowable asset from the sender to Morpho
                └── it should return the assets and the shares repaid
.
└── supplyCollateral(Market memory market, uint256 assets, address onBehalf, bytes calldata data) external
    ├── when market is not created
    │   └── revert with MARKET_NOT_CREATED
    └── when market is created
        ├── when the assets to supply is zero
        │   └── revert with ZERO_ASSETS
        └── when the assets to supply is not zero
            ├── when onBehalf is the zero address
            │   └── revert with ZERO_ADDRESS
            └── when onBehalf is not the zero address
                ├── it should add assets to collateral[market.id][onBehalf]
                ├── it should emit SupplyCollateral(market.id, msg.sender, onBehalf, assets)
                ├── if data.length > 0
                │   └── it should call sender's onMorphoSupplyCollateral callback
                └── it should transfer assets of the collateral asset from the sender to Morpho
.
└── withdrawCollateral(Market memory market, uint256 assets, address onBehalf, address receiver) external
    ├── when market is not created
    │   └── revert with MARKET_NOT_CREATED
    └── when market is created
        ├── when the assets to withdraw is zero
        │   └── revert with ZERO_ASSETS
        └── when the assets to withdraw is not zero
            ├── when receiver is the zero address
            │   └── revert with ZERO_ADDRESS
            └── when receiver is not the zero address
                ├── when not sender and not approved
                │   └── revert with MANAGER_NOT_APPROVED
                └── when sender or approved
                    ├── it should accrue the interest
                    ├── it should remove assets from collateral[market.id][onBehalf]
                    ├── it should emit WithdrawCollateral(market.id, msg.sender, onBehalf, receiver, assets)
                    ├── it should transfer assets of the collateral asset to the receiver
                    └── when position is not healthy
                        └── revert with INSUFFICIENT_COLLATERAL
.
└── liquidate(Market memory market, address borrower, uint256 seized, bytes calldata data) external
    ├── when market is not created
    │   └── revert with MARKET_NOT_CREATED
    └── when market is created
        ├── when the assets to seized is zero
        │   └── revert with ZERO_ASSETS
        └── when the assets to seized is not zero
            ├── it should accrue the interest
            ├── when position is healthy
            │   └── revert with HEALTHY_POSITION
            └── when the position is not healthy
                ├── it should compute repaid = seized.mulDivUp(collateralPrice, ORACLE_PRICE_SCALE).wDivUp(incentive)
                ├── it should compute repaidShares = repaid.toSharesDown(totalBorrow[market.id], totalBorrowShares[market.id]);
                ├── it should remove repaidShares from borrowShares[market.id][borrower]
                ├── it should remove repaidShares from totalBorrowShares[market.id]
                ├── it should remove repaid from totalBorrow[market.id]
                ├── it should remove seized from collateral[market.id][borrower]
                ├── if after the liquidation the borrower's collateral is 0
                │   └── it should realize bad debt
                │       ├── it should compute badDebt = borrowShares[market.id][borrower].toAssetsUp(totalBorrow[market.id], totalBorrowShares[market.id])
                │       ├── it should remove badDebt from totalSupply[market.id]
                │       ├── it should remove badDebt from totalBorrow[market.id]
                │       ├── it should remove borrowShares[market.id][borrower] from totalBorrowShares[market.id]
                │       └── it should set borrowShares[market.id][borrower] to 0
                ├── it should transfer seized of collateral asset to the sender
                ├── it should emit Liquidate(market.id, msg.sender, borrower, repaid, repaidShares, seized, badDebtShares)
                ├── if data.length > 0
                │   └── it should call sender's onMorphoLiquidate callback
                └── it should transfer repaid of borrowable asset from the sender the Morpho
.
└── flashLoan(address token, uint256 assets, bytes calldata data) external
    ├── it should transfer assets of token from Morpho to the sender
    ├── it should call sender's onMorphoFlashLoan callback
    ├── it should emit FlashLoan(msg.sender, token, assets)
    └── it should transfer assets of token from the sender to Morpho
.
└── setAuthorizationWithSig(Authorization memory authorization, Signature calldata signature) external
    ├── when block.timestamp >= authorization.deadline
    │   └── revert with SIGNATURE_EXPIRED
    └── when block.timestamp < deadline
        ├── when authorization.nonce != nonce[authorization.authorizer]
        │   └── revert with INVALID_NONCE
        └── when authorization.nonce == nonce[authorization.authorizer]
            ├── when the signature is invalid or not signed by authorization.authorizer
            │   └── revert with INVALID_SIGNATURE
            └── when the signature is valid and signed by authorization.authorizer
                ├── it should increment authorization.authorizer's nonce
                ├── it should emit IncrementNonce(msg.sender, authorization.authorizer, authorization.nonce)
                ├── it should set isAuthorized[authorization.authorizer][authorization.authorized] to authorization.isAuthorized
                └── it should emit SetAuthorization(msg.sender, authorization.authorizer, authorization.authorized, authorization.isAuthorized)
.
└── setAuthorization(address authorized, bool newIsAuthorized) external
    ├── should set isApproved[msg.sender][authorized] to newIsAuthorized
    └── it should emit SetAuthorization(msg.sender, msg.sender, authorized, newIsAuthorized)
.
└── accrueInterest(Market memory market) external
    ├── when market is not created
    │   └── revert with MARKET_NOT_CREATED
    └── when market is created
        └── it should accrue the interest
.
└── _accrueInterest(Market memory market, Id id) internal
    └── when interest not already accrued in the block
        ├── it should set lastUpdate to block.timestamp
        └── when marketTotalBorrow is not 0
            ├── it should compute accruedInterest = marketTotalBorrow.wMulDown(borrowRate.wTaylorCompounded(elapsed))
            ├── it should add accruedInterest to totalBorrow
            ├── it should add accruedInterest to totalSupply
            └── when fee[id] != 0
            │   ├── it should add accruedInterest.wMulDown(fee[id]) to feeAmount
            │   ├── it should add feeAmount.mulDivDown(totalSupplyShares[id], totalSupply[id] - feeAmount) to supplyShares[id][feeRecipient]
            │   └── it should add feeAmount.mulDivDown(totalSupplyShares[id], totalSupply[id] - feeAmount) to totalSupplyShares[id]
            └── it should emit AccrueInterest(id, borrowRate, accruedInterest, feeShares)
.
└── _isHealthy(Market memory market, Id id, address user, uint256 collateralPrice) internal
    ├── it should compute borrowed = borrowShares[id][user].toAssetsUp(totalBorrow[id], totalBorrowShares[id])
    ├── it should compute maxBorrow = collateral[id][user].mulDivDown(collateralPrice, ORACLE_PRICE_SCALE).wMulDown(market.lltv)
    └── it should return maxBorrow >= borrowed
.
└── liquidationIncentiveFactor(uint256 lltv) internal
    └── it should return min(MAX_LIQUIDATION_INCENTIVE_FACTOR, WAD.wDivDown(WAD - LIQUIDATION_CURSOR.wMulDown(WAD - lltv)))
